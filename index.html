<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Learning</title>
</head>
<body>
    <h1>Hello Git !</h1>
</body>
1- COMMENCER 

Bienvenue dans le tutoriel Vue !

Le but de ce didacticiel est de vous donner rapidement une exp√©rience de ce que l'on ressent en travaillant avec Vue, directement dans le navigateur. Il n'a pas vocation √† √™tre exhaustif, et vous n'avez pas besoin de tout comprendre avant de passer √† autre chose. Cependant, apr√®s l'avoir termin√©, assurez-vous de lire √©galement le guide qui couvre chaque sujet plus en d√©tail.

Conditions pr√©alables

Le didacticiel suppose une connaissance de base de HTML, CSS et JavaScript. Si vous √™tes totalement nouveau dans le d√©veloppement front-end, ce n'est peut-√™tre pas la meilleure id√©e de sauter directement dans un framework comme premi√®re √©tape - saisissez les bases puis revenez ! Une exp√©rience pr√©alable avec d'autres cadres aide, mais n'est pas obligatoire.

Comment utiliser ce didacticiel

Vous pouvez modifier le code sur la droite et voir la mise √† jour des r√©sultats instantan√©ment. Chaque √©tape introduira une fonctionnalit√© principale de Vue, et vous devrez compl√©ter le code pour que la d√©mo fonctionne. Si vous √™tes bloqu√©, vous aurez un "Montre-moi!" bouton qui r√©v√®le le code de travail pour vous. Essayez de ne pas trop vous y fier - vous apprendrez plus vite en d√©couvrant les choses par vous-m√™me.

Si vous √™tes un d√©veloppeur exp√©riment√© venant de Vue 2 ou d'autres frameworks, vous pouvez modifier quelques param√®tres pour tirer le meilleur parti de ce didacticiel. Si vous √™tes d√©butant, il est recommand√© d'utiliser les valeurs par d√©faut.

D√©tails des param√®tres du didacticiel

Pr√™t ? Cliquez sur "Suivant" pour commencer.

*************************************

2- Rendu d√©claratif

La fonctionnalit√© principale de Vue est le rendu d√©claratif : en utilisant une syntaxe de mod√®le qui √©tend le HTML, nous pouvons d√©crire √† quoi le HTML devrait ressembler en fonction de l'√©tat de JavaScript. Lorsque l'√©tat change, le HTML se met √† jour automatiquement.

L'√©tat qui peut d√©clencher des mises √† jour lorsqu'il est modifi√© est consid√©r√© comme r√©actif . Dans Vue, l'√©tat r√©actif est maintenu dans les composants. Dans l'exemple de code, l'objet transmis createApp()est un composant.

Nous pouvons d√©clarer l'√©tat r√©actif en utilisant l' dataoption component, qui devrait √™tre une fonction qui renvoie un objet :

js

createApp({

  data() {

    return {

      message: 'Hello World!'

    }

  }

})

La messagepropri√©t√© sera rendue disponible dans le mod√®le. Voici comment nous pouvons rendre un texte dynamique bas√© sur la valeur de message, en utilisant la syntaxe des moustaches :

mod√®le

<h1>{{ message }}</h1>

Le contenu √† l'int√©rieur des moustaches n'est pas limit√© aux seuls identifiants ou chemins - nous pouvons utiliser n'importe quelle expression JavaScript valide :

mod√®le

<h1>{{ message.split('').reverse().join('') }}</h1>

Maintenant, essayez de cr√©er vous-m√™me une propri√©t√© de donn√©es et utilisez-la comme contenu textuel pour <h1>le mod√®le.

Partie exercice 

<script type="module">

import { createApp } from 'vue'

createApp({

  // component options

  // declare some reactive state here.

}).mount('#app')

</script>

<div id="app">

  <h1>Make me dynamic!</h1>

</div> 

*************************************

3- Liaisons d'attributs

Dans Vue, les moustaches ne sont utilis√©es que pour l'interpolation de texte. Pour lier un attribut √† une valeur dynamique, nous utilisons la v-binddirective :

mod√®le

<div v-bind:id="dynamicId"></div>

Une directive est un attribut sp√©cial qui commence par le v-pr√©fixe. Ils font partie de la syntaxe du mod√®le de Vue. Semblables aux interpolations de texte, les valeurs de directive sont des expressions JavaScript qui ont acc√®s √† l'√©tat du composant. Les d√©tails complets de la v-bindsyntaxe des directives sont abord√©s dans Guide - Syntaxe des mod√®les .

La partie apr√®s les deux-points ( :id) est "l'argument" de la directive. Ici, l' idattribut de l'√©l√©ment sera synchronis√© avec la dynamicIdpropri√©t√© de l'√©tat du composant.

Parce v-bind qu'il est utilis√© si fr√©quemment, il a une syntaxe abr√©g√©e d√©di√©e :

mod√®le

<div :id="dynamicId"></div>

Maintenant, essayez d'ajouter une classliaison dynamique au <h1>, en utilisant la titleClass propri√©t√© data comme valeur. S'il est correctement reli√©, le texte devrait devenir rouge.

Partie exercise

<script type="module">

import { createApp } from 'vue'

createApp({

  data() {

    return {

      titleClass: 'title'

    }

  }

}).mount('#app')

</script>

<div id="app">

  <h1>Make me red</h1> <!-- add dynamic class binding here -->

</div> 

*************************************

4- Ecouteurs d'√©v√©nements

Nous pouvons √©couter les √©v√©nements DOM en utilisant la v-ondirective :

mod√®le

<button v-on:click="increment">{{ count }}

</button>

En raison de son utilisation fr√©quente, v-ona √©galement une syntaxe abr√©g√©e :

mod√®le

<button @click="increment">{{ count }}

</button>

Ici, increment fait r√©f√©rence √† une fonction d√©clar√©e √† l'aide de l' methodsoption :

js

createApp({

  data() {

    return {

      count: 0

    }

  },

  methods: {

    increment() {

      // update component state

      this.count++

    }

  }

})

Dans une m√©thode, nous pouvons acc√©der √† l'instance du composant en utilisant this. L'instance de composant expose les propri√©t√©s de donn√©es d√©clar√©es par data. Nous pouvons mettre √† jour l'√©tat du composant en mutant ces propri√©t√©s.

Les gestionnaires d'√©v√©nements peuvent √©galement utiliser des expressions en ligne et peuvent simplifier les t√¢ches courantes avec des modificateurs. Ces d√©tails sont trait√©s dans Guide - Gestion des √©v√©nements .

Maintenant, essayez d'impl√©menter la increment m√©thode vous-m√™me et de la lier au bouton en utilisant v-on.

<script type="module">

import { createApp } from 'vue'

createApp({

  data() {

    return {

      count: 0

    }

  }

}).mount('#app')

</script>

<div id="app">

  <!-- make this button work -->

  <button>count is: {{ count }}</button>

</div>

*************************************

5- Liaisons de formulaire

En utilisant v-bind et v-on ensemble, nous pouvons cr√©er des liaisons bidirectionnelles sur les √©l√©ments d'entr√©e de formulaire :

mod√®le

<input :value="text" @input="onInput">

js

methods: {

  onInput(e) {

    // a v-on handler receives the native DOM event

    // as the argument.

    this.text = e.target.value

  }

}

Essayez de taper dans la zone de saisie - vous devriez voir le texte se mettre √† <p> jour au fur et √† mesure que vous tapez.

Pour simplifier les liaisons bidirectionnelles, Vue fournit une directive, v-model qui est essentiellement un sucre de syntaxe pour ce qui pr√©c√®de :

mod√®le

<input v-model="text">

v-model synchronise automatiquement la <input> valeur de avec l'√©tat li√©, nous n'avons donc plus besoin d'utiliser un gestionnaire d'√©v√©nements pour cela.

v-model fonctionne non seulement sur les entr√©es de texte, mais √©galement sur d'autres types d'entr√©e tels que les cases √† cocher, les boutons radio et les listes d√©roulantes de s√©lection. Nous couvrons plus de d√©tails dans Guide-Form Bindings .

Maintenant, essayez de refactoriser le code pour l'utiliser √† la v-model place.

<script type="module">

import { createApp } from 'vue'

createApp({

  data() {

    return {

      text: ''

    }

  },

  methods: {

    onInput(e) {

      this.text = e.target.value

    }

  }

}).mount('#app')

</script>

<div id="app">

  <input :value="text" @input="onInput" placeholder="Type here">

  <p>{{ text }}</p>

</div>

*************************************

6- Rendu conditionnel

Nous pouvons utiliser la v-ifdirective pour restituer conditionnellement un √©l√©ment :

mod√®le

<h1 v-if="awesome">Vue is awesome!</h1>

Cela <h1>ne sera rendu que si la valeur de awesomeest truthy . Si awesomela valeur est fausse , elle sera supprim√©e du DOM.

On peut aussi utiliser v-elseet v-else-ifpour d√©signer d'autres branches de la condition :

mod√®le

<h1 v-if="awesome">Vue is awesome!</h1>

<h1 v-else>Oh no üò¢</h1>

Actuellement, la d√©mo affiche les deux <h1>s en m√™me temps et le bouton ne fait rien. Essayez d'y ajouter des directives et impl√©mentez la v-ifm√©thode afin que nous puissions utiliser le bouton pour basculer entre elles.v-elsetoggle()

Plus de d√©tails sur v-if: Guide - Rendu conditionnel

<script type="module">

import { createApp } from 'vue'

createApp({

  data() {

    return {

      awesome: true

    }

  },

  methods: {

    toggle() {

      // ...

    }

  }

}).mount('#app')

</script>

<div id="app">

  <button @click="toggle">toggle</button>

  <h1>Vue is awesome!</h1>

  <h1>Oh no üò¢</h1>

</div> 

*************************************

7- Rendu de la liste

Nous pouvons utiliser la v-fordirective pour afficher une liste d'√©l√©ments bas√©e sur un tableau source :

mod√®le

<ul>

  <li v-for="todo in todos" :key="todo.id">

    {{ todo.text }}

  </li>

</ul>

Voici todoune variable locale repr√©sentant l'√©l√©ment de tableau en cours d'it√©ration. Il n'est accessible que sur ou √† l'int√©rieur de l' v-for√©l√©ment, similaire √† une port√©e de fonction.

Remarquez comment nous donnons √©galement √† chaque objet todo un unique id, et le lions en tant qu'attribut sp√©cialkey pour chacun <li>. Cela keypermet √† Vue de d√©placer avec pr√©cision chacun <li>pour correspondre √† la position de son objet correspondant dans le tableau.

Il existe deux mani√®res de mettre √† jour la liste :

Appelez les m√©thodes de mutation sur le tableau source :

js

this.todos.push(newTodo)

Remplacez le tableau par un nouveau :

js

this.todos = this.todos.filter(/* ... */)

Ici, nous avons une simple liste de t√¢ches - essayez d'impl√©menter la logique addTodo()et removeTodo()les m√©thodes pour que cela fonctionne !

Plus de d√©tails sur v-for: Guide - Rendu Liste

<script type="module">

import { createApp } from 'vue'

// give each todo a unique id

let id = 0

createApp({

  data() {

    return {

      newTodo: '',

      todos: [

        { id: id++, text: 'Learn HTML' },

        { id: id++, text: 'Learn JavaScript' },

        { id: id++, text: 'Learn Vue' }

      ]

    }

  },

  methods: {

    addTodo() {

      // ...

      this.newTodo = ''

    },

    removeTodo(todo) {

      // ...

    }

  }

}).mount('#app')

</script>

<div id="app">

  <form @submit.prevent="addTodo">

    <input v-model="newTodo">

    <button>Add Todo</button>    

  </form>

  <ul>

    <li v-for="todo in todos" :key="todo.id">

      {{ todo.text }}

      <button @click="removeTodo(todo)">X</button>

    </li>

  </ul>

</div>

*************************************

8- Propri√©t√© calcul√©e

Continuons √† b√¢tir sur la liste des t√¢ches √† partir de la derni√®re √©tape. Ici, nous avons d√©j√† ajout√© une fonctionnalit√© de basculement √† chaque t√¢che. Cela se fait en ajoutant une donepropri√©t√© √† chaque objet todo et en l'utilisant v-modelpour la lier √† une case √† cocher :

mod√®le

<li v-for="todo in todos">

  <input type="checkbox" v-model="todo.done">

  ...

</li>

La prochaine am√©lioration que nous pouvons ajouter est de pouvoir masquer les t√¢ches d√©j√† termin√©es. Nous avons d√©j√† un bouton qui bascule l' hideCompleted√©tat. Mais comment rendons-nous diff√©rents √©l√©ments de liste en fonction de cet √©tat ?

Pr√©sentation de la propri√©t√© calcul√©e . Nous pouvons d√©clarer une propri√©t√© qui est calcul√©e de mani√®re r√©active √† partir d'autres propri√©t√©s en utilisant l' computedoption :

js

createApp({

  // ...

  computed: {

    filteredTodos() {

      // return filtered todos based on `this.hideCompleted`

    }

  }

})

diff√©rence

- <li v-for="todo in todos">

+ <li v-for="todo in filteredTodos">

Une propri√©t√© calcul√©e suit les autres √©tats r√©actifs utilis√©s dans son calcul en tant que d√©pendances. Il met en cache le r√©sultat et le met automatiquement √† jour lorsque ses d√©pendances changent.

Maintenant, essayez d'ajouter la filteredTodospropri√©t√© calcul√©e et impl√©mentez sa logique de calcul ! Si elle est correctement impl√©ment√©e, cocher une t√¢che lors du masquage des √©l√©ments termin√©s devrait √©galement la masquer instantan√©ment.

<script type="module">

import { createApp } from 'vue'

let id = 0

createApp({

  data() {

    return {

      newTodo: '',

      hideCompleted: false,

      todos: [

        { id: id++, text: 'Learn HTML', done: true },

        { id: id++, text: 'Learn JavaScript', done: true },

        { id: id++, text: 'Learn Vue', done: false }

      ]

    }

  },

  computed: {

    // ...

  },

  methods: {

    addTodo() {

      this.todos.push({ id: id++, text: this.newTodo, done: false })

      this.newTodo = ''

    },

    removeTodo(todo) {

      this.todos = this.todos.filter((t) => t !== todo)

    }

  }

}).mount('#app')

</script>

<div id="app">

  <form @submit.prevent="addTodo">

    <input v-model="newTodo">

    <button>Add Todo</button>

  </form>

  <ul>

    <li v-for="todo in todos" :key="todo.id">

      <input type="checkbox" v-model="todo.done">

      <span :class="{ done: todo.done }">{{ todo.text }}</span>

      <button @click="removeTodo(todo)">X</button>

    </li>

  </ul>

  <button @click="hideCompleted = !hideCompleted">

    {{ hideCompleted ? 'Show all' : 'Hide completed' }}

  </button>

</div>

*************************************

9- Cycle de vie et r√©f√©rences de mod√®le

Jusqu'√† pr√©sent, Vue g√©rait pour nous toutes les mises √† jour du DOM, gr√¢ce √† la r√©activit√© et au rendu d√©claratif. Cependant, il y aura in√©vitablement des cas o√π nous devrons travailler manuellement avec le DOM.

Nous pouvons demander une r√©f√©rence de mod√®le - c'est-√†-dire une r√©f√©rence √† un √©l√©ment du mod√®le - en utilisant l' attribut sp√©cialref :

mod√®le

<p ref="p">hello</p>

L'√©l√©ment sera expos√© au this.$refsformat this.$refs.p. Cependant, vous ne pouvez y acc√©der qu'une fois le composant mont√© .

Pour ex√©cuter le code apr√®s le montage, nous pouvons utiliser l' mountedoption :

js

createApp({

  mounted() {

    // component is now mounted.

  }

})

C'est ce qu'on appelle un hook de cycle de vie - il nous permet d'enregistrer un rappel √† appeler √† certains moments du cycle de vie du composant. Il existe d'autres crochets tels que createdetupdated . Consultez le diagramme de cycle de vie pour plus de d√©tails.

Maintenant, essayez d'ajouter unmounted hook, acc√©dez au via et effectuez des op√©rations DOM directes dessus (par exemple, changer son ).<p>this.$refs.ptextContent

<script type="module">

import { createApp } from 'vue'

createApp({

  // ...

}).mount('#app')

</script>

<div id="app">

  <p ref="p">hello</p>

</div>

*************************************

10- Observateurs

Parfois, nous pouvons avoir besoin d'effectuer des "effets secondaires" de mani√®re r√©active - par exemple, enregistrer un num√©ro sur la console lorsqu'il change. Nous pouvons y parvenir avec des observateurs :

js

export default {

  data() {

    return {

      count: 0

    }

  },

  watch: {

    count(newCount) {

      // yes, console.log() is a side effect

      console.log(`new count is: ${newCount}`)

    }

  }

}

Ici, nous utilisons l' watchoption pour surveiller les modifications apport√©es √† la countpropri√©t√©. Le rappel watch est appel√© en cas countde changement et re√ßoit la nouvelle valeur comme argument. Plus de d√©tails sont couverts dans Guide-Watchers .

Un exemple plus pratique que la connexion √† la console serait de r√©cup√©rer de nouvelles donn√©es lorsqu'un ID change. Le code que nous avons r√©cup√®re les donn√©es todos d'une API fictive sur le montage du composant. Il y a aussi un bouton qui incr√©mente l'ID de t√¢che qui doit √™tre r√©cup√©r√©. Essayez d'impl√©menter un observateur qui r√©cup√®re une nouvelle t√¢che lorsque le bouton est cliqu√©.

<script type="module">

import { createApp } from 'vue'

createApp({

  data() {

    return {

      todoId: 1,

      todoData: null

    }

  },

  methods: {

    async fetchData() {

      this.todoData = null

      const res = await fetch(

        `https://jsonplaceholder.typicode.com/todos/${this.todoId}`

      )

      this.todoData = await res.json()

    }

  },

  mounted() {

    this.fetchData()

  }

}).mount('#app')

</script>

<div id="app">

  <p>Todo id: {{ todoId }}</p>

  <button @click="todoId++">Fetch next todo</button>

  <p v-if="!todoData">Loading...</p>

  <pre v-else>{{ todoData }}</pre>

</div>

*************************************

11- Composants

Jusqu'√† pr√©sent, nous n'avons travaill√© qu'avec un seul composant. Les applications Real Vue sont g√©n√©ralement cr√©√©es avec des composants imbriqu√©s.

Un composant parent peut restituer un autre composant de son mod√®le en tant que composant enfant. Pour utiliser un composant enfant, nous devons d'abord l'importer :

js

import ChildComp from './ChildComp.js'

createApp({

  components: {

    ChildComp

  }

})

Nous devons √©galement enregistrer le composant √† l'aide de l' componentsoption. Ici, nous utilisons le raccourci de propri√©t√© d'objet pour enregistrer le ChildCompcomposant sous la ChildCompcl√©.

√âtant donn√© que nous √©crivons le mod√®le dans le DOM, il sera soumis aux r√®gles d'analyse du navigateur, qui ne sont pas sensibles √† la casse pour les noms de balises. Par cons√©quent, nous devons utiliser le nom en casse kebab pour r√©f√©rencer le composant enfant :

mod√®le

<child-comp></child-comp>

Maintenant, essayez-le vous-m√™me - importez le composant enfant et affichez-le dans le mod√®le.

<script type="module">

import { createApp } from 'vue'

createApp({

  // register child component

}).mount('#app')

</script>

<div id="app">

  <!-- render child component -->

</div>

*************************************

12- Accessoires

Un composant enfant peut accepter une entr√©e du parent via props . Tout d'abord, il doit d√©clarer les props qu'il accepte :

js

// in child component

export default {

  props: {

    msg: String

  }

}

Une fois d√©clar√©, le msgprop est expos√© thiset peut √™tre utilis√© dans le mod√®le du composant enfant.

Le parent peut transmettre l'accessoire √† l'enfant, tout comme les attributs. Pour passer une valeur dynamique, on peut aussi utiliser la v-bindsyntaxe :

mod√®le

<child-comp :msg="greeting"></child-comp>

Maintenant, essayez-le vous-m√™me dans l'√©diteur.<script type="module">

import { createApp } from 'vue'

import ChildComp from './ChildComp.js'

createApp({

  components: {

    ChildComp

  },

  data() {

    return {

      greeting: 'Hello from parent'

    }

  }

}).mount('#app')

</script>

<div id="app">

  <child-comp></child-comp>

</div>

*************************************

13- √âmet

En plus de recevoir des accessoires, un composant enfant peut √©galement √©mettre des √©v√©nements vers le parent :

js

export default {

  // declare emitted events

  emits: ['response'],

  created() {

    // emit with argument

    this.$emit('response', 'hello from child')

  }

}

Le premier argument de est le nom de l'√©v√©nement. Tous les arguments suppl√©mentaires sont transmis √† l'√©couteur d'√©v√©nement.this.$emit()

Le parent peut √©couter les √©v√©nements √©mis par l'enfant en utilisant v-on- ici, le gestionnaire re√ßoit l'argument suppl√©mentaire de l'appel d'√©mission de l'enfant et l'affecte √† l'√©tat local :

mod√®le

<child-comp @response="(msg) => childMsg = msg"></child-comp>

Maintenant, essayez-le vous-m√™me dans l'√©diteur.

<script type="module">

import { createApp } from 'vue'

import ChildComp from './ChildComp.js'

createApp({

  components: {

    ChildComp

  },

  data() {

    return {

      childMsg: 'No child msg yet'

    }

  }

}).mount('#app')

</script>

<div id="app">

  <child-comp></child-comp>

  <p>{{ childMsg }}</p>

</div>

*************************************

14- Machines √† sous

En plus de transmettre des donn√©es via des accessoires, le composant parent peut √©galement transmettre des fragments de mod√®le √† l'enfant via des slots :

mod√®le

<child-comp>

  This is some slot content!

</child-comp>

Dans le composant enfant, il peut restituer le contenu de l'emplacement du parent en utilisant l' <slot>√©l√©ment comme point de vente :

mod√®le

<!-- in child template -->

<slot></slot>

Le contenu √† l'int√©rieur de l' <slot>outlet sera trait√© comme un contenu "de secours" : il sera affich√© si le parent n'a transmis aucun contenu d'emplacement :

mod√®le

<slot>Fallback content</slot>

Actuellement, nous ne transmettons aucun contenu d'emplacement √† <ChildComp>, vous devriez donc voir le contenu de remplacement. Fournissons du contenu de slot √† l'enfant tout en utilisant l' msg√©tat du parent.<script type="module">

import { createApp } from 'vue'

import ChildComp from './ChildComp.js'

createApp({

  components: {

    ChildComp

  },

  data() {

    return {

      msg: 'from parent'

    }

  }

}).mount('#app')

</script>

<div id="app">

  <child-comp></child-comp>

</div>

*************************************

15- Tu l'as fait!

Vous avez termin√© le tutoriel !

√Ä ce stade, vous devriez avoir une bonne id√©e de ce que c'est que de travailler avec Vue. Cependant, nous avons couvert beaucoup de choses tr√®s rapidement et pass√© sous silence les d√©tails, alors continuez √† apprendre ! √Ä l'√©tape suivante, vous pouvez :

Configurez un vrai projet Vue sur votre machine en suivant le Quick Start .

Parcourez le Guide principal , qui couvre tous les sujets que nous avons appris jusqu'√† pr√©sent avec plus de d√©tails, et bien plus encore.

D√©couvrez quelques exemples plus pratiques .

Nous avons h√¢te de voir ce que vous construisez ensuite !

<script type="module">

import { createApp } from 'vue'

import JSConfetti from 'js-confetti'

const confetti = new JSConfetti()

createApp({

  mounted() {

    this.showConfetti()

  },

  methods: {

    showConfetti() {

      confetti.addConfetti()

    }

  }

}).mount('#app')

</script>

<div id="app">

  <h1 @click="showConfetti">üéâ Congratulations!</h1>

</div>

*************************************
</html>
